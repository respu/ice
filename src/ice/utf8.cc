// Copyright 2006 Nemanja Trifunovic
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <ice/utf8.h>
#include <ice/error.h>
#include <iterator>
#include <cstdint>

namespace ice {
namespace {

class error_category_impl : public std::error_category {
public:
  virtual const char* name() const noexcept override
  {
    return "ice::unicode_error";
  }

  virtual std::string message(int error) const override
  {
    switch (error) {
    case utf8::internal::UTF8_OK: return "Success.";
    case utf8::internal::NOT_ENOUGH_ROOM: return "Not enough room.";
    case utf8::internal::INVALID_LEAD: return "Invalid lead.";
    case utf8::internal::INCOMPLETE_SEQUENCE: return "Incomplete sequence.";
    case utf8::internal::OVERLONG_SEQUENCE: return "Overlong sequence.";
    case utf8::internal::INVALID_CODE_POINT: return "Invalide code point.";
    }
    return std::to_string(error);
  }
};

const std::error_category& error_category()
{
  static error_category_impl instance;
  return instance;
}

std::error_code make_error(int e)
{
  return std::error_code(e, error_category());
}

std::error_code make_error(int e, char c)
{
  // TODO: Report the UTF-8 character.
  return std::error_code(e, error_category());
}

std::error_code make_error(int e, std::uint16_t c)
{
  // TODO: Report the UTF-16 character.
  return std::error_code(e, error_category());
}

std::error_code make_error(int e, std::uint32_t cp)
{
  // TODO: Report the unicode code point.
  return std::error_code(e, error_category());
}

template <typename octet_iterator>
std::uint32_t next(octet_iterator& it, octet_iterator end, std::error_code& ec)
{
  std::uint32_t cp = 0;
  auto err_code = utf8::internal::validate_next(it, end, cp);
  if (err_code != utf8::internal::UTF8_OK) {
    switch (err_code) {
    case utf8::internal::UTF8_OK:
      break;
    case utf8::internal::NOT_ENOUGH_ROOM:
      ec = make_error(err_code);
      break;
    case utf8::internal::INVALID_LEAD:
    case utf8::internal::INCOMPLETE_SEQUENCE:
    case utf8::internal::OVERLONG_SEQUENCE:
      ec = make_error(err_code, *it);
      break;
    case utf8::internal::INVALID_CODE_POINT:
      ec = make_error(err_code, cp);
      break;
    default:
      ec = make_error(err_code);
      break;
    }
  }
  return cp;
}

}  // namespace

std::string u16to8(const ice::u16string_view src)
{
  std::error_code ec;
  auto dst = u16to8(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-16 to UTF-8.";
  }
  return dst;
}

std::string u16to8(const ice::u16string_view src, std::error_code& ec)
{
  std::string dst;
  auto start = src.begin();
  auto end = src.end();
  auto result = std::back_inserter(dst);
  while (start != end) {
    std::uint32_t cp = utf8::internal::mask16(*start++);
    if (utf8::internal::is_lead_surrogate(cp)) {
      // Take care of surrogate pairs first.
      if (start != end) {
        std::uint32_t trail_surrogate = utf8::internal::mask16(*start++);
        if (utf8::internal::is_trail_surrogate(trail_surrogate)) {
          cp = (cp << 10) + trail_surrogate + utf8::internal::SURROGATE_OFFSET;
        } else {
          ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(trail_surrogate));
          break;
        }
      } else {
        ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(cp));
        break;
      }
    } else if (utf8::internal::is_trail_surrogate(cp)) {
      // Lone trail surrogate.
      ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(cp));
      break;
    }
    result = utf8::append(cp, result);
  }
  return dst;
}

std::u16string u8to16(const ice::string_view src)
{
  std::error_code ec;
  auto dst = u8to16(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-8 to UTF-16.";
  }
  return dst;
}

std::u16string u8to16(const ice::string_view src, std::error_code& ec)
{
  std::u16string dst;
  auto start = src.begin();
  auto end = src.end();
  auto result = std::back_inserter(dst);
  while (start != end) {
    std::uint32_t cp = next(start, end, ec);
    if (ec) {
      return dst;
    }
    if (cp > 0xffff) {
      // Make a surrogate pair.
      *result++ = static_cast<uint16_t>((cp >> 10) + utf8::internal::LEAD_OFFSET);
      *result++ = static_cast<uint16_t>((cp & 0x3ff) + utf8::internal::TRAIL_SURROGATE_MIN);
    } else
      *result++ = static_cast<uint16_t>(cp);
  }
  return dst;
}

std::string u32to8(const ice::u32string_view src)
{
  std::error_code ec;
  auto dst = u32to8(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-32 to UTF-8.";
  }
  return dst;
}

std::string u32to8(const ice::u32string_view src, std::error_code& ec)
{
  std::string dst;
  auto start = src.begin();
  auto end = src.end();
  auto result = std::back_inserter(dst);
  while (start != end) {
    auto cp = *(start++);
    if (!utf8::internal::is_code_point_valid(cp)) {
      ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(cp));
      break;
    }
    if (cp < 0x80) // one octet
      *(result++) = static_cast<uint8_t>(cp);
    else if (cp < 0x800) { // two octets
      *(result++) = static_cast<uint8_t>((cp >> 6) | 0xc0);
      *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
    } else if (cp < 0x10000) { // three octets
      *(result++) = static_cast<uint8_t>((cp >> 12) | 0xe0);
      *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
      *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
    } else { // four octets
      *(result++) = static_cast<uint8_t>((cp >> 18) | 0xf0);
      *(result++) = static_cast<uint8_t>(((cp >> 12) & 0x3f) | 0x80);
      *(result++) = static_cast<uint8_t>(((cp >> 6) & 0x3f) | 0x80);
      *(result++) = static_cast<uint8_t>((cp & 0x3f) | 0x80);
    }
  }
  return dst;
}

std::u32string u8to32(const ice::string_view src)
{
  std::error_code ec;
  auto dst = u8to32(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-8 to UTF-16.";
  }
  return dst;
}

std::u32string u8to32(const ice::string_view src, std::error_code& ec)
{
  std::u32string dst;
  auto start = src.begin();
  auto end = src.end();
  auto result = std::back_inserter(dst);
  while (start != end) {
    std::uint32_t cp = next(start, end, ec);
    if (ec) {
      return dst;
    }
    (*result++) = cp;
  }
  return dst;
}


std::string convert(const ice::wstring_view src)
{
  std::error_code ec;
  auto dst = convert(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert a native wide string to UTF-8.";
  }
  return dst;
}

std::string convert(const ice::wstring_view src, std::error_code& ec)
{
  auto size = sizeof(ice::wstring_view::value_type);
  switch (size) {
  case sizeof(char16_t): return u16to8({ reinterpret_cast<const char16_t*>(src.data()), src.size() });
  case sizeof(char32_t): return u32to8({ reinterpret_cast<const char32_t*>(src.data()), src.size() });
  case sizeof(char): return std::string(reinterpret_cast<const char*>(src.data()), src.size());
  default: ec = std::make_error_code(std::errc::invalid_argument);
  }
  return std::string();
}

std::wstring convert(const ice::string_view src)
{
  std::error_code ec;
  auto dst = convert(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-8 to a native wide string.";
  }
  return dst;
}

std::wstring convert(const ice::string_view src, std::error_code& ec)
{
  // TODO: Write a new implementation that does not copy.
  auto size = sizeof(ice::wstring_view::value_type);
  switch (size) {
  case sizeof(char16_t): return reinterpret_cast<const wchar_t*>(u8to16(src).data());
  case sizeof(char32_t): return reinterpret_cast<const wchar_t*>(u8to32(src).data());
  case sizeof(char) : return std::wstring(reinterpret_cast<const wchar_t*>(src.data()), src.size());
  default: ec = std::make_error_code(std::errc::invalid_argument);
  }
  return std::wstring();
}

bool is_valid_utf8(ice::string_view str)
{
  return utf8::is_valid(str.begin(), str.end());
}

}  // namespace ice