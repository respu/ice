// Copyright 2006 Nemanja Trifunovic
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <ice/convert.h>
#include <ice/error.h>
#include <utf8.h>
#include <iterator>
#include <cstdint>

namespace ice {
namespace {

class error_category_impl : public std::error_category {
public:
  virtual const char* name() const noexcept override
  {
    return "ice::unicode_error";
  }

  virtual std::string message(int error) const override
  {
    switch (error) {
    case utf8::internal::UTF8_OK: return "Success.";
    case utf8::internal::NOT_ENOUGH_ROOM: return "Not enough room.";
    case utf8::internal::INVALID_LEAD: return "Invalid lead.";
    case utf8::internal::INCOMPLETE_SEQUENCE: return "Incomplete sequence.";
    case utf8::internal::OVERLONG_SEQUENCE: return "Overlong sequence.";
    case utf8::internal::INVALID_CODE_POINT: return "Invalide code point.";
    }
    return std::to_string(error);
  }
};

const std::error_category& error_category()
{
  static error_category_impl instance;
  return instance;
}

std::error_code make_error(int e)
{
  return std::error_code(e, error_category());
}

std::error_code make_error(int e, char c)
{
  // TODO: Report the UTF-8 character.
  return std::error_code(e, error_category());
}

std::error_code make_error(int e, std::uint16_t c)
{
  // TODO: Report the UTF-16 character.
  return std::error_code(e, error_category());
}

std::error_code make_error(int e, std::uint32_t cp)
{
  // TODO: Report the unicode code point.
  return std::error_code(e, error_category());
}

template <typename octet_iterator>
std::uint32_t next(octet_iterator& it, octet_iterator end, std::error_code& ec)
{
  std::uint32_t cp = 0;
  auto err_code = utf8::internal::validate_next(it, end, cp);
  if (err_code != utf8::internal::UTF8_OK) {
    ec = make_error(err_code);
  }
  switch (err_code) {
  case utf8::internal::UTF8_OK:
    break;
  case utf8::internal::NOT_ENOUGH_ROOM:
    ec = make_error(err_code);
    break;
  case utf8::internal::INVALID_LEAD:
  case utf8::internal::INCOMPLETE_SEQUENCE:
  case utf8::internal::OVERLONG_SEQUENCE:
    ec = make_error(err_code, *it);
    break;
  case utf8::internal::INVALID_CODE_POINT:
    ec = make_error(err_code, cp);
    break;
  }
  return cp;
}

}  // namespace

std::string convert(const ice::u16string_view src)
{
  std::error_code ec;
  auto dst = convert(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-16 to UTF-8.";
  }
  return dst;
}

std::string convert(const ice::u16string_view src, std::error_code& ec)
{
  std::string dst;

  auto start = src.begin();
  auto end = src.end();
  auto result = std::back_inserter(dst);

  while (start != end) {
    std::uint32_t cp = utf8::internal::mask16(*start++);
    if (utf8::internal::is_lead_surrogate(cp)) {
      // Take care of surrogate pairs first.
      if (start != end) {
        std::uint32_t trail_surrogate = utf8::internal::mask16(*start++);
        if (utf8::internal::is_trail_surrogate(trail_surrogate)) {
          cp = (cp << 10) + trail_surrogate + utf8::internal::SURROGATE_OFFSET;
        } else {
          ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(trail_surrogate));
          break;
        }
      } else {
        ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(cp));
        break;
      }
    } else if (utf8::internal::is_trail_surrogate(cp)) {
      // Lone trail surrogate.
      ec = make_error(utf8::internal::INVALID_CODE_POINT, static_cast<uint16_t>(cp));
      break;
    }
    result = utf8::append(cp, result);
  }
  return dst;
}

std::u16string convert(const ice::string_view src)
{
  std::error_code ec;
  auto dst = convert(src, ec);
  if (ec) {
    throw ice::system_error(ec)
      << "Could not convert UTF-8 to UTF-16.";
  }

  if (ec) { throw ice::system_error(ec) << "Could not convert UTF-8 to UTF-16."; }
  return dst;
}

std::u16string convert(const ice::string_view src, std::error_code& ec)
{
  std::u16string dst;

  auto start = src.begin();
  auto end = src.end();
  auto result = std::back_inserter(dst);

  while (start != end) {
    std::uint32_t cp = next(start, end, ec);
    if (ec) {
      return dst;
    }
    if (cp > 0xffff) {
      // Make a surrogate pair.
      *result++ = static_cast<uint16_t>((cp >> 10) + utf8::internal::LEAD_OFFSET);
      *result++ = static_cast<uint16_t>((cp & 0x3ff) + utf8::internal::TRAIL_SURROGATE_MIN);
    } else
      *result++ = static_cast<uint16_t>(cp);
  }
  return dst;
}

bool is_valid_utf8(ice::string_view str)
{
  return utf8::is_valid(str.begin(), str.end());
}

}  // namespace ice